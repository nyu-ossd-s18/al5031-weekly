---
layout: post
title: Week 2
---


# Bazaar vs. Cathedral Models of Building Software (in my words)

To me, the cathedral model is VERY reminiscent of the ways big software engineering companies build their products. I am in the course Software Engineering taught by Amos Bloomberg, and what he is teaching seems to be the cathedral model to me. It is very cool because at the other end of the spectrum I have this class which I equate to the bazaar model. 

So the cathedral model is picking out a specialized team, hopefully one where the individual's strengths will make up for the individual's weaknesses. The team is then handed specifications on the particular product to build; these specs may follow the waterfall or agile development models (weirdly, these also resemble cathedral vs. bazaar). The product is then built according to the selected models. In cathedral, the blueprints and design is laid out and agreed upon. Once the product is finished according to the specs, it is time to review. Should a pillar be in the way of an important vent, which went unnoticed during design and build, there is not much to do because you can't really move the pillar without caving in a part of the ceiling of the cathedral. I say cathedral models are better for products that have already been built and specs are common - this will make for good efficiency. Not to mention, cathedral SHOULD be used in science-heavy and accuracy-important builds (ie. NASA).

With bazaar, there is no pre-selected team; anyone can join and form part of the community, as in regular bazaars (which I think of as swap meets). In swap meets, anyone can come and sell their own value propositions to the public at the price they want. The stands are not made with anything permanent, so if they are in the way of say, the bathroom line, they can simply be moved back and restructured - in this way, the bathroom line is now open and the stand is in a relatively equal state. The bazaar model is best for experimental approaches and new designs, as implementing changes is easier and is not prone to affect the whole system.

I think I would be more comfortable with the cathedral model. I am just more like that. I like having pre-defined rules and specs to follow so as to know I won't mess anything up if I follow them correctly. I haven't worked extensively with either so it remains to be seen which one I end up preferring in my long-term career.

# 2 Lessons

'The Mail Must Get Through' - "1. Every good work of software starts by scratching a developer's personal itch." 

The first one is one I most identify with. I pride myself on my ability to identify problems and find creative fixes around them. Problems attract me for the unsolved factor and I get a really enjoyable high when I solve them. I love identifying stupid little problems whose very existence bothers me. I identify these problems in almost everything, stemming from an OCD-like brain; I love identifying these problems in tech because I have an innate feeling, after taking the field of study up for a few years now, that I am able to fix them. Being skilled in software development will give me the ability to satify that 'personal itch' and actually do something about things I don't like - something many people in many fields are unable to do (have control).

'The Social Context of Open-Source Software' - "18. To solve an interesting problem, start by finding a problem that is interesting to you." 

This quote resonates with me. Many people I know don't like that I took up engineering as a field of study as they come from business-heavy circles. In short, business was the expected field of study for me to go in to, but, in the end, I would HATE studying business as the problems it poses simply don't interest me. I love that software development throws constant and continous hurdles at you, the developer, to fix. Tech is a fascinating field for me: it carries with it so many issues and incredible discoveries waiting to be found by fixing these issues. 




